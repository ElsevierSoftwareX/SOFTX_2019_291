/**
* @file asciiPlotter.hpp
* @brief Class used to plot functions on the terminal.
* @author Aurel Neic
* @version
* @date 2016-12-13
*/


#ifndef _ASCII_PLOTTER
#define _ASCII_PLOTTER

#include<stdio.h>
#include<stdlib.h>
#include<cmath>

#include<iostream>
#include<vector>
#include<string>
#include<algorithm>

#include<assert.h>



template<class V>
class piecewiseLinear_function
{
  private:
  const std::vector<V> & _xval;
  const std::vector<V> & _yval;

  public:
  piecewiseLinear_function(const std::vector<V> & xval, const std::vector<V> & yval): _xval(xval), _yval(yval)
  {
    assert(_xval.size() == _yval.size());
    assert(_xval.size() > 1);
  }

  bool operator()(const V x, V & y)
  {
    V xs = _xval[0], xe = _xval[1], ys = _yval[0], ye = _yval[1];

    if( (x < _xval[0]) || (x > _xval[_xval.size()-1]) )
      return false;

    size_t size = _xval.size();
    unsigned int i=1;
    while(x > xe && i < size-1) {
      xs = _xval[i], xe = _xval[i+1];
      ys = _yval[i], ye = _yval[i+1];
      i++;
    }

    V fctr = (x - xs) / (xe - xs);
    y = ys + (ye - ys)*fctr;

    return true;
  }
};


/**
 *  The asciiPlotter class plots vectors of function values using ascii characters on stdout.
 */
class asciiPlotter
{
  private:
    std::vector< std::vector<char> > _canvas;  ///< Here the functions will be drawn on
    unsigned int _rows;                        ///< Number of rows
    unsigned int _cols;                        ///< Number of columns
    double _x_min, _x_max, _x_div;             ///< x range and division
    double _y_min, _y_max, _y_div;             ///< y range and division

    /// reset the canvas
    void reset()
    {
      for(unsigned int i=0; i<_rows; i++) {
        _canvas[i].assign(_cols + 1, ' ');
        _canvas[i][_cols] = '\0';
      }
      _x_min = -1;
      _x_max = -1;
      _x_div = -1;
      _y_min = -1;
      _y_max = -1;
      _y_div = -1;
    }

    /// compute x range and division
    template<class V>
    void compute_xrange(const std::vector<V> & x)
    {
      _x_min = x[0], _x_max = x[x.size()-1];
      _x_div = (_x_max - _x_min) / (_cols - 1);
    }
    /// compute y range and division
    template<class V>
    void compute_yrange(const std::vector<V> & func)
    {
      _y_min = func[0], _y_max = func[0];
      for(size_t i=0; i<func.size(); i++) {
        if(_y_min > func[i]) _y_min = func[i];
        if(_y_max < func[i]) _y_max = func[i];
      }
      _y_div = (_y_max - _y_min) / (_rows - 1);
    }

    /// draw a function graph on the canvas
    template<class V>
    void draw_graph(const std::vector<V> & x, const std::vector<V> & y, char pt)
    {
      piecewiseLinear_function<V> func(x,y);
      size_t dpd = 10; // draws per division

      for(size_t i=0; i<_cols*dpd; i++) {
        size_t xidx = i/dpd;
        V xval = _x_min + float(i)/float(dpd)*_x_div;
        V yval;
        if(func(xval, yval))
        {
          unsigned int yidx = (yval - _y_min) / _y_div;
          if(yidx < _rows)
            _canvas[_rows-1 - yidx][xidx] = pt;
        }
      }
    }

    /// print out the top line
    void print_topline()
    {
      printf("         ");
      for(size_t i=0; i<_cols+2; i++) printf("-");
      printf("\n");
    }
    /// print out the bottom line
    void print_botline()
    {
      printf("         ");
      for(size_t i=0; i<_cols+2; i++) printf("-");
      printf("\n");

      unsigned int bsize = 8;
      unsigned int nblocks = _cols / bsize;
      printf("     ");
      for(size_t i=0; i<=nblocks; i++) {
        if(i%2 == 0) printf("%8.1lf", _x_min + i*bsize*_x_div);
        else         printf("        ");
      }
      printf("\n");
    }


  public:
    /// empty constructor
    asciiPlotter() :
                 _rows(0),
                 _cols(0),
                 _x_min(-1),
                 _x_max(-1),
                 _x_div(-1),
                 _y_min(-1),
                 _y_max(-1),
                 _y_div(-1)
    {}
    /** main constructor
     *
     *  also sets the size of the canvas.
     */
    asciiPlotter(const unsigned int rows, const unsigned int cols) :
                 _rows(0),
                 _cols(0)
    {
      this->setSize(rows, cols);
    }

    /// set canvas size
    void setSize(const unsigned int rows, const unsigned int cols)
    {
      _rows = rows;
      _cols = cols;

      _canvas.resize(_rows);
      this->reset();
    }

    /** add an additional graph to the plot
     *
     *  x values are autogenerated as [0, func.size()]
     *
     *  \param  func  vector of function values to draw
     *  \param  pt    charactor to use for drawing the function
     */
    template<class V>
    void add_graph(const std::vector<V> & func, char pt)
    {
      assert(_cols > 0 && _rows > 0);

      std::vector<V> x(func.size());
      for(size_t i=0; i<func.size(); i++) x[i] = i;

      if(_x_div < 0) compute_xrange(x);
      if(_y_div < 0) compute_yrange(func);

      draw_graph(x, func, pt);
    }
    /** add an additional graph to the plot
     *
     *  \param  x     vector with x values of the function to draw
     *  \param  y     vector with y values of the function to draw
     *  \param  pt    charactor to use for drawing the function
     */
    template<class V>
    void add_graph(const std::vector<V> & x, const std::vector<V> & y, char pt)
    {
      assert(_cols > 0 && _rows > 0);
      assert(x.size() == y.size());

      if(_x_div < 0) compute_xrange(x);
      if(_y_div < 0) compute_yrange(y);

      draw_graph(x, y, pt);
    }

    /// print the plot on stdout
    void print()
    {
      print_topline();
      for(size_t i=0; i<_rows; i++) {
        if( (i == 0) || (_rows-1-i)%4 == 0 )
          printf("%+8.2lf |%s|\n", _y_max - i*_y_div, _canvas[i].data());
        else
          printf("         |%s|\n", _canvas[i].data());
      }
      print_botline();
    }

    /// set x range according to min/max of the given vector
    template<class V>
    void set_xrange(const std::vector<V> & x)
    {
      this->compute_xrange(x);
    }
    /// set x range
    template<class V>
    void set_xrange(V min, V max)
    {
      _x_min = min;
      _x_max = max;
      _x_div = (_x_max - _x_min) / (_cols - 1);
    }

    /// set y range according to min/max of the given function
    template<class V>
    void set_yrange(const std::vector<V> & func)
    {
      this->compute_yrange(func);
    }
    /// set y range
    template<class V>
    void set_yrange(V min, V max)
    {
      _y_min = min;
      _y_max = max;
      _y_div = (_y_max - _y_min) / (_rows - 1);
    }
};


/**
* @brief Class that generates a histogramm for a data vector and
*        prints it using asciiPlotter.
*
* @tparam V  Type of the data vector.
*/
template<class V>
class histogramm_plotter
{
  private:
  asciiPlotter         _plotter;      ///< the plotter we will use to plot the histogramm
  std::vector<float>   _xval, _yval;  ///< the x and y function values to plot
  size_t _num_int;                    ///< number of histogramm intervals

  V _min, _max;
  double _avrg, _sum, _stddev;

  void stats(const std::vector<V> & data)
  {
    _min = data[0], _max = data[0];
    _sum = 0.0;
    _stddev = 0.0;

    for(size_t i=0; i<data.size(); i++)
    {
      V c = data[i];
      if(_min > c) _min = c;
      if(_max < c) _max = c;
      _sum += c;
    }
    _avrg = _sum / double(data.size());

    // calculate standard deviation
    for(size_t i=0; i<data.size(); i++) {
      V c = data[i];
      _stddev += (c - _avrg)*(c - _avrg);
    }
    _stddev /= (double(data.size()) - 1.);
    _stddev = std::sqrt(_stddev);
  }

  void generate_xy(const std::vector<V> & data)
  {
    this->stats(data);

    float delta = float(_max - _min) / float(_num_int);

    for(size_t i=0; i<_num_int+1; i++) {
      _xval[i] = float(_min) + i*delta;
      _yval[i] = 0.0f;
    }

    for(size_t i=0; i < data.size(); i++) {
      size_t idx = size_t((data[i] - _min) / delta);
      if(idx < _num_int+1)
        _yval[idx] += 1.0f;
    }
    for(size_t i=0; i<_num_int+1; i++) _yval[i] /= ((float)data.size());
  }

  public:
  histogramm_plotter(size_t num_int, size_t rows, size_t cols) :
                     _plotter(rows, cols), _xval(num_int+1), _yval(num_int+1), _num_int(num_int)
  {}

  void plot(const std::vector<V> & data, std::string msg)
  {
    this->generate_xy(data);

    _plotter.set_xrange(_min, _max);
    _plotter.set_yrange(_yval);
    _plotter.add_graph(_xval, _yval, '*');
#if 0
    std::cout << msg << std::endl << std::endl;
    std::cout << "Average: " << _avrg << ", (min: " << _min << ", max: " << _max << ")" << std::endl;
    std::cout << std::endl << " == Histogramm == " << std::endl << std::endl;
#else
    printf("%s\n\n", msg.c_str());
    printf("Sum: %g, Mean: %g, Stddev: %g, Min: %g, Max: %g\n", _sum, _avrg, _stddev, double(_min), double(_max));
    printf(" == Histogramm ==\n\n");
#endif
    _plotter.print();
  }
};

/**
* @brief Ascii matrix graph plotter
*
* @tparam VEC vector class that offers a basic std::vector-like API.
*/
template<class VEC>
class matrixgraph_plotter
{
  private:
    std::vector< std::vector<char> > _canvas;  ///< The canvas we draw on
    unsigned int _rows;                        ///< Number of rows
    unsigned int _cols;                        ///< Number of columns


    /**
    * @brief The private printing function.
    *
    * @param cnt Row counts of the matrix graph
    * @param col Column indices of the matrix graph
    * @param s   Character used for drawing.
    */
    void draw_matrix(const VEC & cnt,
                     const VEC & col,
                     char s)
    {
      long int nrow = cnt.size();
      long int ncol = *std::max_element(col.begin(), col.end()) + 1;
      int xdiv = (ncol + _cols - 1) / _cols;
      int ydiv = (nrow + _rows - 1) / _rows;

      for(size_t i=0, k=0; i<cnt.size(); i++)
        for(long int j=0; j < cnt[i]; j++, k++) {
          int ypos = i / ydiv;
          int xpos = col[k] / xdiv;
          _canvas[ypos][xpos] = s;
        }
    }


  public:
    /// empty constructor
    matrixgraph_plotter() : _rows(0), _cols(0)
    {}

    /**
    * @brief Constructor specifying the canvas size
    *
    * @param rows  Number of rows
    * @param cols  Number of cols
    */
    matrixgraph_plotter(const unsigned int rows, const unsigned int cols)
    {
      this->setSize(rows, cols);
    }

    /**
    * @brief Clear the canvas
    */
    void reset()
    {
      for(unsigned int i=0; i<_rows; i++) {
        _canvas[i].assign(_cols + 1, ' ');
        _canvas[i][_cols] = '\0';
      }
    }

    /**
    * @brief Set new size and clear the canvas
    *
    * @param rows  Number of rows
    * @param cols  Number of cols
    */
    void setSize(const unsigned int rows, const unsigned int cols)
    {
      _rows = rows;
      _cols = cols;

      _canvas.resize(_rows);
      this->reset();
    }

    /**
    * @brief Print a matrix graph to stdout.
    *
    * @param cnt Row counts of the matrix graph
    * @param col Column indices of the matrix graph
    * @param s   Character used for drawing.
    */
    void print(const VEC & cnt,
               const VEC & col,
               char s)
    {
      draw_matrix(cnt, col, s);

      for(size_t i=0; i<_rows; i++) {
          printf("    |%s|\n", _canvas[i].data());
      }
    }
};



#endif

